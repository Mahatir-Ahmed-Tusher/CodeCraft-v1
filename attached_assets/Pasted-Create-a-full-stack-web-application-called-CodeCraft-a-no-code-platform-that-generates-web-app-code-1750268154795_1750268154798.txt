Create a full-stack web application called CodeCraft, a no-code platform that generates web app code from natural language prompts, allows users to view/edit code, save it as files on the server, download it as a zip file, and preview it in real-time. The frontend will use React with TypeScript, Tailwind CSS, and WebContainer for in-browser execution, while the backend will use Node.js with Express, integrating the Groq API (llama-3.3-70b-versatile) for code generation. Do not include authentication; all features should be accessible without login. The application must run in a WebContainer environment, adhering to its constraints (no native binaries, no Git, prefer Vite for web servers). Below are the detailed requirements for functionality, UI, backend logic, and deliverables.

Functionality
Prompt Input and Code Generation:
Frontend Interface:
Create a chat-like interface (inspired by Builder.tsx) where users enter natural language prompts (e.g., "Build a to-do list app with React and Express").
Display the chat history (prompts and AI responses) in a chat bubble style, similar to ChatGPT, with user prompts on the right and AI responses on the left.
Include an "Improve Prompt" button that sends the prompt to the Groq API to refine vague inputs (e.g., "Create a website" → "Create a to-do list website with React and Express").
Show generated code in a split-screen view:
Left: Chat interface for prompt input and history.
Right: Code output with tabs for each generated file (e.g., src/App.tsx, index.js).
Use Monaco Editor (as in CodeEditor.tsx) for viewing and editing code, with syntax highlighting for JavaScript/TypeScript.
Backend Logic (based on index.ts, prompts.ts):
Initialize the Groq API in index.ts using:
python

Collapse

Wrap

Run

Copy
from langchain_groq import ChatGroq
import os
from dotenv import load_dotenv

load_dotenv()
GROQ_API_KEY = os.environ.get("GROQ_API_KEY")
llm = ChatGroq(
    temperature=0.7,
    groq_api_key=GROQ_API_KEY,
    model_name="llama-3.3-70b-versatile"
)
Replace the Anthropic AI calls in index.ts with Groq API calls, maintaining the same endpoints:
POST /template:
Takes a prompt from the request body.
Sends the prompt to the Groq API with a system prompt (adapted from prompts.ts) to return either "node" or "react" to determine the project type.
Returns a JSON object with:
prompts: An array with the BASE_PROMPT (from prompts.ts) and a modified version of the Node.js (node.ts) or React (react.ts) base prompt, including a note about unshown files (.gitignore, package-lock.json).
uiPrompts: An array with the Node.js or React base prompt.
If the response is invalid, return a 403 error: { "message": "Invalid project type" }.
POST /chat:
Takes a messages array (chat history) from the request body.
Sends the messages to the Groq API with the system prompt from getSystemPrompt() (from prompts.ts), modified to use Groq and include WebContainer constraints.
Returns the AI’s response as a JSON object: { "response": "..." }.
Logs the response to the console for debugging.
Use the BASE_PROMPT from prompts.ts to ensure generated code is production-worthy, using JSX, Tailwind CSS, React hooks, and Lucide React icons for React projects, and modular Node.js code for backend projects.
Generate code as <boltArtifact> structures (as in node.ts, react.ts), including:
Shell commands (e.g., npm install --save-dev vite, npm run dev).
Files (e.g., index.js, src/App.tsx, package.json) with full content, no placeholders.
Folders (e.g., src/, api/) if needed.
Validate generated code using ESLint (for JavaScript/TypeScript) before returning it to the frontend. If invalid, return an error message: { "error": "Invalid code generated" }.
Code Saving and Management:
Frontend:
Allow users to save the generated project with a name and description, entered via a modal form (with fade-in animation).
Display a "My Projects" page (inspired by Builder.tsx) listing all saved projects with columns: Name, Description, Date Created, Actions (View, Edit, Delete, Download).
Provide a button to download the project as a zip file containing all files (e.g., src/, api/).
Backend:
Store project metadata in a projects.json file in the server’s filesystem (e.g., { "project_id": "project1", "name": "To-Do App", "description": "A simple to-do app", "files": ["src/App.tsx", "index.js"] }).
Save project files in a directory structure: projects/<project_id>/ (e.g., projects/project1/src/App.tsx).
Implement endpoints:
POST /save-project: Takes { project_id, name, description, files }, saves metadata to projects.json, and writes files to projects/<project_id>/.
GET /projects: Returns the contents of projects.json.
GET /project/:project_id: Returns the metadata and file contents for a specific project.
DELETE /project/:project_id: Deletes the project’s metadata and files.
GET /download/:project_id: Generates a zip file of the project’s files and returns it as a downloadable stream.
Use the fs module (Node.js) for file operations, ensuring WebContainer compatibility (no native binaries).
Preview and Deployment:
Frontend (inspired by PreviewFrame.tsx):
Display a live preview of the generated app in a resizable iframe, updated in real-time as users edit code.
Use WebContainer to run the project (e.g., npm install, npm run dev) and capture the server URL via the server-ready event.
Include a "Refresh" button to reload the iframe after code edits.
Show a loading spinner (like Loader.tsx) while the server starts.
Backend:
Provide an endpoint POST /preview/:project_id:
Takes a project_id and mounts the project’s files to WebContainer.
Runs npm install and npm run dev to start the development server.
Returns the WebContainer server URL for the frontend to use in the iframe.
Ensure the backend passes the project’s file structure to WebContainer, using the same mounting logic as in Builder.tsx.
Deployment:
Implement a "Deploy" button that hosts the app on a Replit-provided subdomain (e.g., project1--username.repl.co).
Add an endpoint POST /deploy/:project_id:
Uses Replit’s hosting API to deploy the project.
Returns the deployed URL or an error message if deployment fails.
Error Handling and Validation:
Frontend:
Display user-friendly error messages (e.g., "Failed to generate code. Try refining your prompt.") in a toast notification with Tailwind CSS styling.
Highlight invalid code in the Monaco Editor with ESLint warnings.
Backend:
Validate generated code with ESLint (for JavaScript/TypeScript) before returning it.
If the Groq API fails or returns invalid code, return a 500 error: { "error": "Code generation failed" }.
Handle WebContainer errors (e.g., failed npm install) by logging details and returning an error response.
Additional Features:
Prompt Refinement:
Add an endpoint POST /improve-prompt:
Takes a prompt and sends it to the Groq API with a system prompt to refine it (e.g., "Make this prompt more specific for a React app").
Returns the refined prompt to the frontend.
Feedback System:
Create a feedback form (modal with fade-in animation) for users to report issues or suggest improvements.
Save feedback in a feedback.json file via a POST /feedback endpoint.
Analytics:
Log user interactions (e.g., prompts submitted, projects saved) in an analytics.json file via a POST /log endpoint.
Example: { "event": "project_saved", "project_id": "project1", "timestamp": "2025-06-18T11:25:00Z" }.
UI Requirements (Inspired by Builder.tsx, FileExplorer.tsx, etc.)
Design:
Create a modern, minimalist design inspired by Vercel’s dashboard or GitHub’s UI, using Tailwind CSS.
Default to dark mode with a toggle for light mode (store preference in local storage).
Use smooth animations (e.g., fade-in for modals, slide-in for sidebars) with Tailwind’s transition classes or Framer Motion.
Ensure a mobile-first, responsive layout that works on all screen sizes.
Navigation:
Include a top navbar with links to:
Home: The main prompt input and code generation page.
My Projects: A list of saved projects.
Add a collapsible sidebar (inspired by FileExplorer.tsx) with:
Prompt input section (chat interface).
File explorer for the current project (like FileExplorer.tsx).
Preview toggle (like TabView.tsx for code/preview modes).
Dark/light mode toggle button.
Chat Interface:
Design the prompt input as chat bubbles (user: right, AI: left) with a history scrollable in a panel (like StepsList.tsx).
Include a textarea and "Send" button (like in Builder.tsx) for submitting prompts.
Add an "Improve Prompt" button next to the textarea.
Code Editor:
Use Monaco Editor (like CodeEditor.tsx) with:
Syntax highlighting for JavaScript/TypeScript.
Line numbers and a dark theme (vs-dark).
Buttons to copy, save, or download the current file.
Display files in tabs (e.g., App.tsx, index.js) with clear file names.
Preview:
Embed a resizable iframe (like PreviewFrame.tsx) for the live app preview.
Include a "Refresh" button and a loading spinner (like Loader.tsx).
My Projects Page:
Show a table with columns: Name, Description, Date Created, Actions (View, Edit, Delete, Download).
Use Tailwind CSS for a clean, responsive table with hover effects.
Backend Logic (Adapted from Previous Discussion)
Core Setup (based on index.ts):
Use Express with TypeScript, running on port 3000.
Enable CORS and JSON parsing middleware.
Load the Groq API key from a .env file:
javascript

Collapse

Wrap

Run

Copy
require("dotenv").config();
const GROQ_API_KEY = process.env.GROQ_API_KEY;
Initialize the Groq API (replace Anthropic):
javascript

Collapse

Wrap

Run

Copy
import { ChatGroq } from "@langchain/groq";
const llm = new ChatGroq({
  temperature: 0.7,
  groqApiKey: GROQ_API_KEY,
  modelName: "llama-3.3-70b-versatile"
});
Code Generation:
For /template:
Send the prompt to the Groq API with a system prompt (from prompts.ts, modified for Groq) to return "node" or "react".
Use templates from node.ts or react.ts to return a <boltArtifact> with files and shell commands.
For /chat:
Send the chat history to the Groq API with the getSystemPrompt() system prompt, ensuring WebContainer constraints (no Git, no native binaries, prefer Vite).
Parse the response as a <boltArtifact> containing files and commands.
Validate code with ESLint before returning.
Structure artifacts to include:
Shell commands (e.g., npm install --save-dev vite && npm run dev).
Files with full content (e.g., src/App.tsx, index.js).
Folders created as needed (e.g., src/).
File Storage:
Store project metadata in projects.json (e.g., { "project_id": "project1", "name": "To-Do App", "files": ["src/App.tsx"] }).
Save files in projects/<project_id>/ directories.
Use Node.js fs module for file operations, ensuring WebContainer compatibility.
Preview Rendering:
For /preview/:project_id:
Mount the project’s files to WebContainer using the same logic as Builder.tsx (convert files to a WebContainer structure).
Run npm install and npm run dev to start the server.
Capture the server-ready event to return the server URL.
Ensure the preview supports React projects (using Vite) and Node.js projects (using Express).
Technical Details
Frontend:
Use Vite + React + TypeScript + Tailwind CSS.
Structure: src/components/ (for FileExplorer, CodeEditor, etc.), src/pages/ (for Home, My Projects).
Use React Router for navigation (Home, My Projects).
Integrate WebContainer (like useWebContainer.ts) for previews.
Dependencies: react, react-dom, react-router-dom, tailwindcss, lucide-react, axios, @monaco-editor/react, @webcontainer/api.
Backend:
Use Express with TypeScript, based on index.ts, prompts.ts, constants.ts, node.ts, react.ts.
Replace Anthropic with @langchain/groq.
Add endpoints: /save-project, /projects, /project/:project_id, /delete/:project_id, /download/:project_id, /preview/:project_id, /improve-prompt, /feedback, /log.
Dependencies: express, cors, dotenv, @langchain/groq, typescript, @types/express, @types/cors, eslint, archiver (for zip files).
Environment Variables:
Store GROQ_API_KEY in .env and provide a .env.example:
plaintext

Collapse

Wrap

Copy
GROQ_API_KEY=your-api-key-here
Validation:
Run ESLint on generated JavaScript/TypeScript files.
Log validation errors to the console and return to the frontend.
Deployment:
Host on a Replit subdomain using Replit’s hosting API.
Generate a dist folder for zip downloads.
Deliverables
A fully functional CodeCraft app hosted on a Replit subdomain.
Source code organized in:
src/ (frontend: components, pages).
server/ (backend: index.ts, prompts.ts, constants.ts, node.ts, react.ts).
projects/ (for saved project files).
A zip download option for the dist folder.
A .env.example file:
plaintext

Collapse

Wrap

Copy
GROQ_API_KEY=your-api-key-here
A README.md with setup instructions, including:
Installing dependencies (npm install).
Setting up the Groq API key.
Running the backend (npm run dev) and frontend (npm run dev).
Accessing the app on the Replit subdomain.
Implementation Notes
Adapt prompts.ts to work with Groq, keeping the WebContainer constraints and <boltArtifact> structure.
Reuse FileExplorer.tsx, CodeEditor.tsx, PreviewFrame.tsx, TabView.tsx, and Loader.tsx for the UI, updating them for the new features (e.g., project saving, zip download).
Ensure the chat interface supports prompt refinement and displays history clearly.
Test the app to confirm:
Code generation produces valid React or Node.js projects.
Previews render correctly in the iframe.
Projects can be saved, listed, and downloaded as zip files.
The UI is responsive and animations are smooth.
This prompt provides a comprehensive blueprint for CodeCraft, leveraging the existing backend logic (Express, TypeScript, WebContainer) and frontend components (React, Tailwind, Monaco Editor) while incorporating the Groq API and UI requirements from the text file. It ensures no authentication, emphasizes backend code generation and preview rendering, and maintains a modern, user-friendly interface. Let me know if you need help refining or implementing specific parts!