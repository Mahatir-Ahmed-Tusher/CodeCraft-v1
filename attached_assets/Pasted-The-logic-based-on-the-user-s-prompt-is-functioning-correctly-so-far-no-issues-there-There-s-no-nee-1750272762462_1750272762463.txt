The logic based on the user's prompt is functioning correctly so far—no issues there. There's no need to change that part. However, the generated code is currently not rendering a live preview.

We need to ensure that the user's desired web app—based on code fetched from our backend—is being properly rendered by executing the necessary commands like npm install, npm run dev, etc. To address this, you may refer to the logic implemented in the Builder.tsx file, which can serve as a useful reference.

⚠️ Important: You're only expected to adapt the logic from Builder.tsx, not copy-paste it. Pay attention to how it functions—what libraries it uses, how the flow is structured, etc.

The Role of Builder.tsx:
It serves multiple purposes in building an interactive UI for live web app generation:

Generates a full website based on the user's prompt.

Displays the generated files (via a file explorer).

Allows users to edit code using Monaco Editor.

Renders a live preview using WebContainer (browser-based Node.js environment).

Lets users send additional prompts to update or refine the code.

All of this is wrapped in a clean and interactive user interface.

Core Logic Flow:
📥 Receiving Prompt:
The user prompt is received via the useLocation hook.

🔗 Backend Communication:
On page load, the init() function is triggered, which makes two API calls:

POST /template: Sends the prompt to receive a base template (e.g., Node.js or React). It returns prompts and uiPrompts in XML format, which are parsed into step instructions.

POST /chat: Sends both the original prompt and the parsed steps to the AI, which returns additional steps (also in XML) to be parsed and added.

🧠 User-Driven Prompt Update:
When a user enters a new prompt in the text area and clicks "Send", a new request is made to /chat along with previous chat history (llmMessages). Returned steps are used to update the file system.

🗂 File System Generation:
Steps tagged as CreateFile are used to build a virtual file structure (e.g., src/App.tsx).

If package.json is missing, a default one is added with required dependencies (React, Vite, Tailwind, etc.).

🧪 WebContainer Integration:
The entire file system is mounted into WebContainer, which runs a browser-based Node.js environment.

Commands like npm install and npm run dev are executed internally to serve the app and render the live preview.

⚠️ Error Handling:
If any backend request fails (e.g., server error), proper error messages are shown.

Axios errors are logged in detail to the console.

💬 Chat History:
All user prompts and AI responses are stored in llmMessages, which are included in follow-up requests.

✅ Summary of the Workflow:
User arrives with a prompt.

Backend returns templates and generation steps.

File system is created and displayed (e.g., App.tsx, index.html).

Code can be viewed and edited.

WebContainer runs the app and shows a live preview.

User can submit additional prompts to iterate the code.

You are encouraged to examine the code inside Builder.tsx and extract the necessary logic as required for implementing this functionality.

Let me know if you’d like help reviewing or adapting any part of Builder.tsx step-by-step.